/**
 * rehype-article-links
 * 
 * A rehype plugin that converts inline article references to clickable deep links.
 * 
 * Uses existing anchor IDs generated by rehype-paragraph-ids.js and builds
 * section IDs compatible with linkBuilder.js conventions.
 * 
 * Processing order:
 *   1. Check manual overrides (exact match from YAML config)
 *   2. Apply regex patterns (ordered by specificity)
 *   3. Skip if no match or matches external reference
 * 
 * ID Format (matches rehype-paragraph-ids.js):
 *   - article-5a
 *   - article-5a-para-1
 *   - article-5a-para-1-point-a
 *   - article-5a-para-1-point-a-subpoint-ii
 *   - annex-i
 *   - annex-i-section-3
 *   - recital-75
 * 
 * @see ARTICLE_CROSSLINK_PLAN.md for implementation details
 */

import { visitParents } from 'unist-util-visit-parents';
import { load as loadYaml } from 'js-yaml';
import { readFileSync, existsSync } from 'fs';

// ═══════════════════════════════════════════════════════════════════════════
// PATTERNS (ordered from most specific to least specific)
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Patterns that should NOT be linked (handled by rehype-external-links or skip entirely)
 */
const SKIP_PATTERNS = [
    /\bthis\s+Regulation\b/gi,
    /\bthis\s+Directive\b/gi,
    /\bthis\s+Article\b/gi,
    /\bof\s+Regulation\s+\(E[UC]\)/gi,      // "Article X of Regulation (EU)" → external
    /\bof\s+Directive\s+\(E[UC]\)/gi,       // "Article X of Directive (EU)" → external
    /\bRegulation\s+\(E[UC]\)\s+(?:No\s+)?\d+\/\d+/gi,  // Full external ref
    /\bDirective\s+\(E[UC]\)\s+(?:No\s+)?\d+\/\d+/gi,   // Full external ref
]

/**
 * External document abbreviations that indicate an external article reference.
 * When these appear after "Article N", the reference should NOT be linked.
 * 
 * Examples:
 *   - "Article 218 TFEU" → Treaty on the Functioning of the European Union
 *   - "Article 6 TEU" → Treaty on European Union
 *   - "Article 47 of the Charter" → Charter of Fundamental Rights
 */
const EXTERNAL_DOC_ABBREVIATIONS = [
    'TFEU',        // Treaty on the Functioning of the European Union
    'TEU',         // Treaty on European Union  
    'TEC',         // Treaty establishing the European Community
    'ECSC',        // European Coal and Steel Community Treaty
    'Charter',     // Charter of Fundamental Rights
    'UDHR',        // Universal Declaration of Human Rights
    'ECHR',        // European Convention on Human Rights
];

/**
 * Internal reference patterns.
 * Order matters: more specific patterns first to prevent partial matches.
 */
const PATTERNS = [
    // Annex with section: "Annex I, Section 3" or "Section 2 of Annex II"
    {
        name: 'ANNEX_SECTION_OF',
        pattern: /\bSection\s+(\d+)\s+of\s+Annex\s+([IVX]+)\b/gi,
        extract: (match) => ({
            annex: match[2].toLowerCase(),
            section: match[1]
        })
    },
    {
        name: 'ANNEX_SECTION',
        pattern: /\bAnnex\s+([IVX]+)(?:,?\s+Section\s+(\d+))?/gi,
        extract: (match) => ({
            annex: match[1].toLowerCase(),
            section: match[2] || null
        })
    },

    // Article with full hierarchy: "Article 5a(1)(b)(ii)"
    // Captures: [1]=article, [2]=paragraph, [3]=point, [4]=subpoint
    {
        name: 'ARTICLE_FULL',
        pattern: /\bArticle\s+(\d+\w?)(?:\s*\(\s*(\d+\w?)\s*\))?(?:\s*\(\s*([a-z])\s*\))?(?:\s*\(\s*([ivxlcdm]+)\s*\))?/gi,
        extract: (match) => ({
            article: match[1].toLowerCase(),
            paragraph: match[2] || null,
            point: match[3] ? match[3].toLowerCase() : null,
            subpoint: match[4] ? match[4].toLowerCase() : null
        })
    },

    // Recital reference: "Recital 75"
    {
        name: 'RECITAL',
        pattern: /\bRecital\s+(\d+)/gi,
        extract: (match) => ({
            recital: match[1]
        })
    },
];

// ═══════════════════════════════════════════════════════════════════════════
// SECTION ID BUILDER (matches linkBuilder.js convention)
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Build section ID from parsed components.
 * Must match format from rehype-paragraph-ids.js
 */
function buildSectionId(components) {
    const { article, paragraph, point, subpoint, annex, section, recital } = components;

    if (recital) {
        return `recital-${recital}`;
    }

    if (annex) {
        let id = `annex-${annex}`;
        if (section) id += `-section-${section}`;
        return id;
    }

    if (article) {
        let id = `article-${article}`;
        if (paragraph) id += `-para-${paragraph}`;
        if (point) id += `-point-${point}`;
        if (subpoint) id += `-subpoint-${subpoint}`;
        return id;
    }

    return null;
}

// ═══════════════════════════════════════════════════════════════════════════
// MAIN PLUGIN
// ═══════════════════════════════════════════════════════════════════════════

export default function rehypeArticleLinks(options = {}) {
    const { overridesPath } = options;

    // Load ALL overrides from all documents (flat list)
    const allOverrides = loadAllOverrides(overridesPath);

    return (tree) => {
        // Collect replacements (don't mutate during traversal)
        const replacements = [];

        visitParents(tree, 'text', (node, ancestors) => {
            // Skip nodes we shouldn't process
            if (shouldSkipNode(ancestors)) return;

            const text = node.value;

            // Skip if text matches external/skip patterns
            for (const skipPattern of SKIP_PATTERNS) {
                skipPattern.lastIndex = 0;
                if (skipPattern.test(text)) {
                    // Check if THIS specific text contains an external ref
                    // We need to be more precise - only skip if the match is within text
                    skipPattern.lastIndex = 0;
                }
            }

            // Check manual overrides first (exact match, highest priority)
            for (const override of allOverrides) {
                if (text.includes(override.text)) {
                    const parent = ancestors[ancestors.length - 1];
                    replacements.push({
                        node,
                        parent,
                        parts: buildOverrideNodes(text, override)
                    });
                    return;  // Only apply first matching override
                }
            }

            // Apply regex patterns
            const parts = applyPatterns(text);
            if (parts && parts.some(p => p.type === 'element')) {
                const parent = ancestors[ancestors.length - 1];
                replacements.push({ node, parent, parts });
            }
        });

        // Apply all replacements (in reverse order to maintain indices)
        for (const { node, parent, parts } of replacements.reverse()) {
            if (!parent?.children) continue;
            const index = parent.children.indexOf(node);
            if (index === -1) continue;
            parent.children.splice(index, 1, ...parts);
        }
    };
}

// ═══════════════════════════════════════════════════════════════════════════
// HELPERS
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Load all overrides from YAML file (flattened across all documents).
 * Overrides are keyed by slug but we flatten them for text matching.
 */
function loadAllOverrides(path) {
    if (!path || !existsSync(path)) return [];
    try {
        const content = readFileSync(path, 'utf-8');
        const data = loadYaml(content) || {};

        // Flatten all document overrides into a single list
        const allOverrides = [];
        for (const slug of Object.keys(data)) {
            const docOverrides = data[slug];
            if (Array.isArray(docOverrides)) {
                for (const override of docOverrides) {
                    allOverrides.push({
                        ...override,
                        _slug: slug  // Keep track of source for debugging
                    });
                }
            }
        }
        return allOverrides;
    } catch (e) {
        console.warn('  ⚠️  Failed to load article-link-overrides.yaml:', e.message);
        return [];
    }
}

/**
 * Check if we should skip this text node.
 * Skip: headings, existing links, code blocks, citation refs
 */
function shouldSkipNode(ancestors) {
    for (const ancestor of ancestors) {
        if (ancestor.type !== 'element') continue;

        const tag = ancestor.tagName;
        const className = ancestor.properties?.className || [];

        // Skip headings (article titles themselves)
        if (/^h[1-6]$/.test(tag)) return true;

        // Skip code blocks
        if (tag === 'code' || tag === 'pre') return true;

        // Skip existing links (prevent nesting)
        if (tag === 'a') return true;

        // Skip citation refs (already processed)
        if (className.includes('citation-ref')) return true;

        // Skip external law links (already processed by rehype-external-links)
        if (className.includes('external-law-link')) return true;
    }

    return false;
}

/**
 * Check if an article match is actually an external reference.
 * These should NOT be linked by this plugin.
 * 
 * @param {string} text - Full text being processed
 * @param {number} matchIndex - Start index of the "Article N" match
 * @param {number} matchEnd - End index of the match
 * @returns {boolean} True if this is an external reference
 */
function isExternalReference(text, matchIndex, matchEnd) {
    // Get context: 50 chars before and 100 chars after (wider window)
    const before = text.slice(Math.max(0, matchIndex - 50), matchIndex);
    const after = text.slice(matchEnd, matchEnd + 100);

    // Check for "of Regulation/Directive (EU)" pattern BEFORE the match
    if (/\bof\s+(Regulation|Directive)\s+\(E[UC]\)/i.test(before)) {
        return true;
    }

    // Check for treaty abbreviations IMMEDIATELY after the match
    // e.g., "Article 218 TFEU" or "Article 47 of the Charter"
    for (const abbrev of EXTERNAL_DOC_ABBREVIATIONS) {
        // Match directly after with just whitespace
        const directPattern = new RegExp(`^\\s+${abbrev}\\b`, 'i');

        if (directPattern.test(after)) {
            return true;
        }
    }

    // Check for full treaty names after "of the"
    // e.g., "Article 218 of the Treaty on the Functioning of the European Union (TFEU)"
    if (/^\s+of\s+the\s+Treaty\b/i.test(after)) {
        return true;
    }

    // Check for "of the Charter" pattern
    if (/^\s+of\s+the\s+Charter\b/i.test(after)) {
        return true;
    }

    return false;
}

/**
 * Apply all patterns to text and return replacement nodes.
 */
function applyPatterns(text) {
    const parts = [];
    let lastIndex = 0;

    // Collect all matches from all patterns
    const matches = [];

    for (const patternDef of PATTERNS) {
        const regex = new RegExp(patternDef.pattern.source, patternDef.pattern.flags);
        let match;

        while ((match = regex.exec(text)) !== null) {
            // Skip if this is part of an external reference
            if (isExternalReference(text, match.index, match.index + match[0].length)) {
                continue;
            }

            const components = patternDef.extract(match);
            const sectionId = buildSectionId(components);

            if (sectionId) {
                matches.push({
                    name: patternDef.name,
                    match,
                    index: match.index,
                    length: match[0].length,
                    text: match[0],
                    sectionId
                });
            }
        }
    }

    // Sort by position
    matches.sort((a, b) => a.index - b.index);

    // Remove overlapping matches (keep first/longer)
    const filtered = [];
    for (const m of matches) {
        const overlaps = filtered.some(f =>
            m.index < f.index + f.length && m.index + m.length > f.index
        );
        if (!overlaps) filtered.push(m);
    }

    // Build replacement nodes
    for (const m of filtered) {
        // Text before match
        if (m.index > lastIndex) {
            parts.push({ type: 'text', value: text.slice(lastIndex, m.index) });
        }

        // The link element
        parts.push({
            type: 'element',
            tagName: 'a',
            properties: {
                href: `#${m.sectionId}`,
                className: ['article-link'],
                'data-section': m.sectionId
            },
            children: [{ type: 'text', value: m.text }]
        });

        lastIndex = m.index + m.length;
    }

    // Remaining text after last match
    if (lastIndex < text.length) {
        parts.push({ type: 'text', value: text.slice(lastIndex) });
    }

    return parts.length > 0 && filtered.length > 0 ? parts : null;
}

/**
 * Build replacement nodes from a manual override definition.
 */
function buildOverrideNodes(text, override) {
    const parts = [];
    const idx = text.indexOf(override.text);

    // Text before override
    if (idx > 0) {
        parts.push({ type: 'text', value: text.slice(0, idx) });
    }

    // Build the override content with embedded links
    let remaining = override.text;
    for (const link of override.links) {
        const linkIdx = remaining.indexOf(link.text);

        if (linkIdx > 0) {
            parts.push({ type: 'text', value: remaining.slice(0, linkIdx) });
        }

        parts.push({
            type: 'element',
            tagName: 'a',
            properties: {
                href: link.target,
                className: ['article-link'],
                title: link.title || null
            },
            children: [{ type: 'text', value: link.text }]
        });

        remaining = remaining.slice(linkIdx + link.text.length);
    }

    if (remaining) {
        parts.push({ type: 'text', value: remaining });
    }

    // Text after override
    if (idx + override.text.length < text.length) {
        parts.push({ type: 'text', value: text.slice(idx + override.text.length) });
    }

    return parts;
}
