# Article Cross-Linking Implementation Plan

> **Status:** ✅ COMPLETE  
> **Created:** 2025-01-25  
> **Implemented:** 2026-01-25 (2,341 article links generated across 44 documents)  
> **Scope:** Intra-document article link generation in document body text

---

## What Already Exists ✅

| Component | File | Status |
|-----------|------|--------|
| **Paragraph-level anchors** | `rehype-paragraph-ids.js` | ✅ Generates `article-X-para-N-point-a-subpoint-i` |
| **Link builder utilities** | `linkBuilder.js` | ✅ `buildSectionId()`, `parseParagraph()` |
| **Component for tools** | `LegalBasisLink.jsx` | ✅ Used in RCA/VCQ |
| **External EUR-Lex links** | `rehype-external-links.js` | ✅ Links non-imported docs to EUR-Lex |
| **External doc registry** | `external-documents.yaml` | ✅ Defines external regulations |

---

## What's Missing ❌

**Inline text linking within document body**

Currently, when a regulation says "pursuant to Article 9(1)", that text is **not** a clickable link. Users must manually scroll to find the article.

### Goal

Transform inline references in document body text into clickable deep links:

| Input Text | Output Link Target |
|------------|-------------------|
| "Article 9" | `#article-9` |
| "Article 9(1)" | `#article-9-para-1` |
| "Article 5a(3)(b)" | `#article-5a-para-3-point-b` |
| "Article 5a(1)(a)(ii)" | `#article-5a-para-1-point-a-subpoint-ii` |
| "Annex I" | `#annex-i` |
| "Annex I, Section 3" | `#annex-i-section-3` |
| "Recital 75" | `#recital-75` |

---

## Architecture

```
Document Body Text
        │
        ▼
┌─────────────────────────────────────────────────────────────────┐
│                    Link Resolution Pipeline                      │
├─────────────────────────────────────────────────────────────────┤
│  1. Check Override Map (exact match) ──────► Found? → Apply it  │
│                          │                                       │
│                          ▼ Not found                             │
│  2. Apply Regex Patterns ──────────────────► Found? → Apply it  │
│                          │                                       │
│                          ▼ Not found                             │
│  3. Leave as plain text                                          │
└─────────────────────────────────────────────────────────────────┘
        │
        ▼
   Clickable Links
```

### Integration with Existing Plugins

```
Markdown Source
      │
      ▼
┌─────────────────────┐
│ remark-parse        │
└──────────┬──────────┘
           ▼
┌─────────────────────┐
│ rehype-paragraph-ids│  ← Adds IDs to paragraphs/points/subpoints
└──────────┬──────────┘
           ▼
┌─────────────────────┐
│ rehype-term-links   │  ← Adds terminology popovers
└──────────┬──────────┘
           ▼
┌─────────────────────────────────────┐
│ rehype-article-links (NEW)          │  ← Adds intra-document links
└──────────┬──────────────────────────┘
           ▼
┌─────────────────────┐
│ rehype-external-links│ ← Links external docs to EUR-Lex
└──────────┬──────────┘
           ▼
    Final HTML
```

**Key:** `rehype-article-links` runs AFTER `rehype-paragraph-ids` (so anchors exist) and BEFORE `rehype-external-links` (to avoid double-processing).

---

## File Structure

```
docs-portal/
├── config/
│   └── article-link-overrides.yaml    # Manual override definitions (NEW)
├── scripts/
│   └── rehype-article-links.js        # Main Rehype plugin (NEW)
└── build-content.js                   # Integration point (MODIFY)
```

---

## Implementation

### Phase 1: Core Plugin

**File: `scripts/rehype-article-links.js`**

```javascript
/**
 * rehype-article-links
 * 
 * Converts inline article references to clickable deep links.
 * 
 * Uses existing anchor IDs generated by rehype-paragraph-ids.js
 * and builds section IDs compatible with linkBuilder.js conventions.
 * 
 * Processing order:
 *   1. Check manual overrides (exact match)
 *   2. Apply regex patterns
 *   3. Skip if no match
 */

import { visitParents } from 'unist-util-visit-parents';
import { load as loadYaml } from 'js-yaml';
import { readFileSync, existsSync } from 'fs';

// ═══════════════════════════════════════════════════════════════
// PATTERNS
// ═══════════════════════════════════════════════════════════════

/**
 * Patterns for intra-document references (ordered by specificity)
 */
const PATTERNS = {
  // Article with full hierarchy: Article 5a(1)(b)(ii)
  ARTICLE_FULL: /\bArticle\s+(\d+\w?)(?:\((\d+\w?)\))?(?:\(([a-z])\))?(?:\(([ivxlcdm]+)\))?/gi,
  
  // Annex with section: Annex I, Section 3
  ANNEX_SECTION: /\bAnnex\s+([IVX]+)(?:,?\s+Section\s+(\d+))?/gi,
  
  // Recital reference
  RECITAL: /\bRecital\s+(\d+)/gi,
};

/**
 * Patterns to SKIP (do not link)
 */
const SKIP_PATTERNS = [
  /\bthis\s+Regulation\b/gi,
  /\bthis\s+Directive\b/gi,
  /\bthis\s+Article\b/gi,
  /\bpursuant\s+to\s+Article\s+\d+\s+of\s+Regulation/gi,  // External ref (handled by rehype-external-links)
  /\bArticle\s+\d+\s+of\s+(?:Regulation|Directive)/gi,     // External ref
];

// ═══════════════════════════════════════════════════════════════
// SECTION ID BUILDER (matches linkBuilder.js convention)
// ═══════════════════════════════════════════════════════════════

/**
 * Build section ID from parsed components.
 * Must match format from rehype-paragraph-ids.js
 */
function buildSectionId(components) {
  const { article, paragraph, point, subpoint, annex, section, recital } = components;
  
  if (recital) {
    return `recital-${recital}`;
  }
  
  if (annex) {
    let id = `annex-${annex.toLowerCase()}`;
    if (section) id += `-section-${section}`;
    return id;
  }
  
  if (article) {
    let id = `article-${article.toLowerCase()}`;
    if (paragraph) id += `-para-${paragraph}`;
    if (point) id += `-point-${point.toLowerCase()}`;
    if (subpoint) id += `-subpoint-${subpoint.toLowerCase()}`;
    return id;
  }
  
  return null;
}

// ═══════════════════════════════════════════════════════════════
// MAIN PLUGIN
// ═══════════════════════════════════════════════════════════════

export default function rehypeArticleLinks(options = {}) {
  const { currentSlug, overridesPath } = options;
  
  // Load overrides
  const overrides = loadOverrides(overridesPath, currentSlug);
  
  return (tree) => {
    // Collect replacements (don't mutate during traversal)
    const replacements = [];
    
    visitParents(tree, 'text', (node, ancestors) => {
      // Skip if in heading (article titles themselves)
      if (isInHeading(ancestors)) return;
      
      // Skip if inside existing link
      if (isInLink(ancestors)) return;
      
      // Skip if inside code block
      if (isInCode(ancestors)) return;
      
      const text = node.value;
      
      // Check skip patterns
      for (const skip of SKIP_PATTERNS) {
        if (skip.test(text)) return;
      }
      
      // Check manual overrides first
      for (const override of overrides) {
        if (text.includes(override.text)) {
          const parent = ancestors[ancestors.length - 1];
          replacements.push({
            node,
            parent,
            parts: buildOverrideNodes(text, override)
          });
          return;
        }
      }
      
      // Apply regex patterns
      const parts = applyPatterns(text);
      if (parts && parts.some(p => p.type === 'element')) {
        const parent = ancestors[ancestors.length - 1];
        replacements.push({ node, parent, parts });
      }
    });
    
    // Apply all replacements
    for (const { node, parent, parts } of replacements) {
      if (!parent?.children) continue;
      const index = parent.children.indexOf(node);
      if (index === -1) continue;
      parent.children.splice(index, 1, ...parts);
    }
  };
}

// ═══════════════════════════════════════════════════════════════
// HELPERS
// ═══════════════════════════════════════════════════════════════

function loadOverrides(path, slug) {
  if (!path || !existsSync(path)) return [];
  try {
    const content = readFileSync(path, 'utf-8');
    const data = loadYaml(content) || {};
    return data[slug] || [];
  } catch (e) {
    console.warn('Failed to load article-link-overrides.yaml:', e.message);
    return [];
  }
}

function isInHeading(ancestors) {
  return ancestors.some(a => 
    a.type === 'element' && /^h[1-6]$/.test(a.tagName)
  );
}

function isInLink(ancestors) {
  return ancestors.some(a => 
    a.type === 'element' && a.tagName === 'a'
  );
}

function isInCode(ancestors) {
  return ancestors.some(a => 
    a.type === 'element' && (a.tagName === 'code' || a.tagName === 'pre')
  );
}

function applyPatterns(text) {
  const parts = [];
  let lastIndex = 0;
  
  // Collect all matches from all patterns
  const matches = [];
  
  for (const [name, pattern] of Object.entries(PATTERNS)) {
    pattern.lastIndex = 0;
    let match;
    while ((match = pattern.exec(text)) !== null) {
      matches.push({
        name,
        match,
        index: match.index,
        length: match[0].length
      });
    }
  }
  
  // Sort by position
  matches.sort((a, b) => a.index - b.index);
  
  // Remove overlapping matches (keep first)
  const filtered = [];
  for (const m of matches) {
    const overlaps = filtered.some(f => 
      m.index < f.index + f.length && m.index + m.length > f.index
    );
    if (!overlaps) filtered.push(m);
  }
  
  // Build parts
  for (const m of filtered) {
    // Text before match
    if (m.index > lastIndex) {
      parts.push({ type: 'text', value: text.slice(lastIndex, m.index) });
    }
    
    // The link
    const sectionId = buildSectionIdFromMatch(m.name, m.match);
    if (sectionId) {
      parts.push({
        type: 'element',
        tagName: 'a',
        properties: {
          href: `#${sectionId}`,
          className: ['article-link'],
          'data-section': sectionId
        },
        children: [{ type: 'text', value: m.match[0] }]
      });
    } else {
      parts.push({ type: 'text', value: m.match[0] });
    }
    
    lastIndex = m.index + m.length;
  }
  
  // Remaining text
  if (lastIndex < text.length) {
    parts.push({ type: 'text', value: text.slice(lastIndex) });
  }
  
  return parts.length > 0 ? parts : null;
}

function buildSectionIdFromMatch(patternName, match) {
  switch (patternName) {
    case 'ARTICLE_FULL': {
      const [, article, paragraph, point, subpoint] = match;
      return buildSectionId({ article, paragraph, point, subpoint });
    }
    case 'ANNEX_SECTION': {
      const [, annex, section] = match;
      return buildSectionId({ annex, section });
    }
    case 'RECITAL': {
      const [, recital] = match;
      return buildSectionId({ recital });
    }
    default:
      return null;
  }
}

function buildOverrideNodes(text, override) {
  const parts = [];
  const idx = text.indexOf(override.text);
  
  // Text before override
  if (idx > 0) {
    parts.push({ type: 'text', value: text.slice(0, idx) });
  }
  
  // Build links from override
  let remaining = override.text;
  for (const link of override.links) {
    const linkIdx = remaining.indexOf(link.text);
    if (linkIdx > 0) {
      parts.push({ type: 'text', value: remaining.slice(0, linkIdx) });
    }
    parts.push({
      type: 'element',
      tagName: 'a',
      properties: {
        href: link.target,
        className: ['article-link'],
        title: link.title || null
      },
      children: [{ type: 'text', value: link.text }]
    });
    remaining = remaining.slice(linkIdx + link.text.length);
  }
  if (remaining) {
    parts.push({ type: 'text', value: remaining });
  }
  
  // Text after override
  if (idx + override.text.length < text.length) {
    parts.push({ type: 'text', value: text.slice(idx + override.text.length) });
  }
  
  return parts;
}
```

---

### Phase 2: Override System

**File: `config/article-link-overrides.yaml`**

```yaml
# Manual overrides for complex article references
# These take precedence over regex pattern matching
#
# Format:
#   "document-slug":
#     - text: "exact text to match"
#       links:
#         - target: "#article-X-para-N" 
#           text: "linked portion"
#           title: "optional tooltip"

# Example: compound ranges (regex can't handle these)
"2014-910":
  - text: "Articles 15 to 22"
    links:
      - target: "#article-15"
        text: "15"
      - target: "#article-22"
        text: "22"

  - text: "Articles 8(3), 9(5), 12(2) to (9)"
    links:
      - target: "#article-8-para-3"
        text: "8(3)"
      - target: "#article-9-para-5"
        text: "9(5)"
      - target: "#article-12-para-2"
        text: "12(2)"
      - target: "#article-12-para-9"
        text: "(9)"

# GDPR compound references
"2016-679":
  - text: "Article 6(1), points (a), (c) and (f)"
    links:
      - target: "#article-6-para-1-point-a"
        text: "(a)"
      - target: "#article-6-para-1-point-c"
        text: "(c)"
      - target: "#article-6-para-1-point-f"
        text: "(f)"
```

---

### Phase 3: Build Integration

**Modify: `scripts/build-content.js`**

Add to the unified pipeline (after `rehype-paragraph-ids`, before `rehype-external-links`):

```javascript
import rehypeArticleLinks from './rehype-article-links.js';

// In the pipeline:
.use(rehypeParagraphIds)          // Existing - adds IDs
.use(rehypeTermLinks, {...})      // Existing - terminology
.use(rehypeArticleLinks, {        // NEW - article cross-links
  currentSlug: frontmatter.slug,
  overridesPath: path.join(__dirname, '../config/article-link-overrides.yaml')
})
.use(rehypeExternalLinks, {...})  // Existing - EUR-Lex links
```

---

### Phase 4: CSS Styling

**Add to existing CSS:**

```css
/* Intra-document article links */
.article-link {
  color: var(--color-primary);
  text-decoration: none;
  border-bottom: 1px dotted var(--color-primary-muted);
  transition: border-color 0.15s ease;
}

.article-link:hover {
  border-bottom-style: solid;
  border-color: var(--color-primary);
}

/* Distinguish from external-law-link (wavy underline) */
.article-link:not(.external-law-link) {
  /* Internal links use dotted underline */
}
```

---

## Decisions Made

| Question | Decision | Rationale |
|----------|----------|-----------|
| **Paragraph anchors** | Use existing format | `rehype-paragraph-ids.js` already generates `article-X-para-N-point-a-subpoint-ii` |
| **EUR-Lex fallback** | Defer to existing | `rehype-external-links.js` already handles this |
| **Tooltip content** | Show section ID | Simple, verifiable, matches anchor |
| **Override precedence** | Override → Regex → Skip | Deterministic, easy to debug |

---

## Estimated Effort

| Phase | Scope | Time |
|-------|-------|------|
| **1** | Core plugin (`rehype-article-links.js`) | 2 hours |
| **2** | Override YAML + initial entries | 30 min |
| **3** | Build integration | 30 min |
| **4** | CSS styling | 15 min |
| **5** | Testing + edge cases | 1 hour |

**Total: ~4-5 hours** (reduced from 9-10 hours by leveraging existing infrastructure)

---

## Success Criteria

- [x] "Article 9" in document body links to `#article-9`
- [x] "Article 9(1)(a)" links to `#article-9-para-1-point-a`
- [x] "Annex I" links to `#annex-i`
- [x] "Recital 75" links to `#recital-75`
- [x] "this Regulation" is NOT linked
- [x] "Article 51 of Regulation (EU) 2016/679" is handled by `rehype-external-links` (EUR-Lex)
- [x] Override system works for compound references
- [x] No false positives or broken links (fixed Article 218 TFEU)

---

## Testing Commands

```bash
# Build single document to test
node scripts/build-content.js --slug=2014-910 --verbose

# Check generated HTML for article links
grep -o 'class="article-link"' public/data/*.json | wc -l

# Validate anchor targets exist
node scripts/validate-article-links.js
```
